# ìžë£Œêµ¬ì¡° & ì•Œê³ ë¦¬ì¦˜

## ðŸ“” ìžë£Œêµ¬ì¡°

### âœ”ï¸ ì—°ê²° ë¦¬ìŠ¤íŠ¸ (Linked List)

- í¬ì¸í„°ë¥¼ ì´ìš©í•´ì„œ ìžë£Œë¥¼ ì—°ì†ì ìœ¼ë¡œ ì €ìž¥í•˜ëŠ” ë°©ì‹
- ì‹œê°„ ë³µìž¡ë„ (Time Complexity)
    - ê²€ìƒ‰: `O(n)`
    - ì‚½ìž…/ì‚­ì œ: `O(n)`



### âœ”ï¸ í (Queue) & ìŠ¤íƒ (Stack) & ë°í¬ (Deque)

- í(Queue)
    - FIFO (First-in First-out); ì‚½ìž… ì‹œ ë¦¬ìŠ¤íŠ¸ì˜ ê°€ìž¥ ë§ˆì§€ë§‰ì— ì¶”ê°€ë˜ë©°, ì‚­ì œ ì‹œ ê°€ìž¥ ì•žì˜ ìš”ì†Œê°€ ë‚˜ì˜¨ë‹¤
- ìŠ¤íƒ(Stack)
    - LIFO(Last-in First-out); ì‚½ìž… ì‹œ ë¦¬ìŠ¤íŠ¸ì˜ ê°€ìž¥ ì•žì— ì¶”ê°€ë˜ë©°, ì‚­ì œ ì‹œì—ë„ ê°€ìž¥ ì•žì˜ ìš”ì†Œê°€ ë‚˜ì˜¨ë‹¤
    - í•¨ìˆ˜ í˜¸ì¶œì˜ ìˆœì„œ ì œì–´ ë° postfix notationìœ¼ë¡œ í‘œí˜„ëœ ì‹ ì—°ì‚° ì‹œ ì‚¬ìš©ì´ ê°€ëŠ¥í•˜ë‹¤
- ë°í¬(Deque; Double Ended Queue)
    - ì‚½ìž…ê³¼ ì‚­ì œê°€ ë¦¬ìŠ¤íŠ¸ì˜ ì–‘ ëì—ì„œ ëª¨ë‘ ë°œìƒ ê°€ëŠ¥í•œ ìžë£Œêµ¬ì¡°



### âœ”ï¸ **íŠ¸ë¦¬ (Tree)**

- Cycleì´ ì—†ëŠ” ê·¸ëž˜í”„
- ìš©ì–´
    - Degree(ì°¨ìˆ˜): ë…¸ë“œ ë³„ ìžì‹ì˜ ìˆ˜, í˜¹ì€ íŠ¸ë¦¬ì˜ ê²½ìš° ì°¨ìˆ˜ ì¤‘ ê°€ìž¥ í° ìˆ˜
    - Terminal Node(ë‹¨ë§ ë…¸ë“œ; Leaf Node): ì°¨ìˆ˜ê°€ 0ì¸ ë…¸ë“œ
    - None-Terminal Node(ë¹„ë‹¨ë§ ë…¸ë“œ): ì°¨ìˆ˜ê°€ 0ì´ ì•„ë‹Œ ë…¸ë“œ
    - Sibling(í˜•ì œ ë…¸ë“œ): ë™ì¼í•œ ë¶€ëª¨ë¥¼ ê°–ëŠ” ë…¸ë“œë“¤



### âœ”ï¸ ì´ì§„ íŠ¸ë¦¬ (Binary Tree)

- ë…¸ë“œì˜ ì°¨ìˆ˜ê°€ 2ì¸ íŠ¸ë¦¬
    - í•œ ë ˆë²¨ì˜ ìµœëŒ€ ë…¸ë“œ ê°œìˆ˜ëŠ” `2^(i-1)`
- ì™„ì „ ì´ì§„íŠ¸ë¦¬ (complete binary tree): ë§ˆì§€ë§‰ levelì„ ì œì™¸í•˜ê³  ëª¨ë“  levelì˜ ë…¸ë“œê°€ `2^(i-1)` ì¸ ê²ƒ; ëª¨ë‘ ì±„ì›Œì§„ ê²ƒ
- **íŠ¸ë¦¬ ìˆœíšŒ (Traversal)**
    - **In-order:** ì™¼ìª½ ë…¸ë“œ - ìžì‹  - ì˜¤ë¥¸ìª½ ë…¸ë“œ ìˆœìœ¼ë¡œ íƒìƒ‰
    - **Pre-order:** ìžì‹  - ì™¼ìª½ ë…¸ë“œ - ì˜¤ë¥¸ìª½ ë…¸ë“œ ìˆœìœ¼ë¡œ íƒìƒ‰
    - **Post-order:** ì™¼ìª½ ë…¸ë“œ - ì˜¤ë¥¸ìª½ ë…¸ë“œ - ìžì‹  ìˆœìœ¼ë¡œ íƒìƒ‰



### âœ”ï¸ ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬ (Binary Search Tree; BST)

- **ì¡°ê±´**
    - ë…¸ë“œ ì™¼ìª½ì— ìžˆëŠ” ëª¨ë“  ì„œë¸ŒíŠ¸ë¦¬ì˜ ê°’ì€ ë…¸ë“œ ê°’ë³´ë‹¤ ìž‘ìŒ
    - ë…¸ë“œ ì˜¤ë¥¸ìª½ì— ìžˆëŠ” ëª¨ë“  ì„œë¸ŒíŠ¸ë¦¬ì˜ ê°’ì€ ë…¸ë“œ ê°’ë³´ë‹¤ í¼
- **ì‹œê°„ ë³µìž¡ë„ (Time Complexity)**
    - ê²€ìƒ‰: `O(log n)`
    - ì‚½ìž…/ì‚­ì œ: `O(log n)`
- **ì‚½ìž…**
    - ìœ„ì¹˜ë¥¼ ì°¾ì•„ê°€ë©° ë¹ˆ ìœ„ì¹˜ì— ë„£ìœ¼ë©´ ë¨
- **ì‚­ì œ**
    - ìžì‹ì´ í•˜ë‚˜ ìžˆìœ¼ë©´ ë…¸ë“œë¥¼ ì‚­ì œí•˜ê³  ê·¸ ìžì‹ì„ ìœ„ë¡œ ì˜¬ë¦¬ë©´ ë¨
    - ìžì‹ì´ ë‘˜ ìžˆìœ¼ë©´ ì˜¤ë¥¸ìª½ ìžì‹ì˜ ì„œë¸ŒíŠ¸ë¦¬ ì¤‘ ê°€ìž¥ ìž‘ì€ ê°’ìœ¼ë¡œ êµì²´í•˜ê³ , í•´ë‹¹ ë…¸ë“œ ë‹¤ì‹œ ì‚­ì œ
        - ê°€ìž¥ ìž‘ì€ ê°’ì€ ê°€ìž¥ ì™¼ìª½ì— ìžˆëŠ” ê°’ì´ë©°, ì´ ë…¸ë“œëŠ” ìžì‹ì´ í•˜ë‚˜ ì´í•˜ ìžˆìŒì´ ë³´ìž¥ë¨

![BST deletion](images/bst-delete.png)



### âœ”ï¸ íž™ (Heap)

- ì™„ì „ì´ì§„íŠ¸ë¦¬(Complete binary tree)
- ë¶€ëª¨ì˜ ê°’ì´ ìžì‹ì˜ ê°’ë³´ë‹¤ í•­ìƒ í¬ê±°ë‚˜ ìž‘ìŒ (í° ê²½ìš°: max-heap, ìž‘ì€ ê²½ìš°: min-heap)
- ë°°ì—´ë¡œ í‘œí˜„ ê°€ëŠ¥
    - ë¶€ëª¨ê°€ `n[i]`ì¼ ë•Œ ì™¼ìª½ ìžì‹ì€ `n[i*2]`, ì˜¤ë¥¸ìª½ ìžì‹ì€ `n[i*2+1]`
- **ì‚½ìž…**
    - ê°€ìž¥ ë§ˆì§€ë§‰ì— (n[n.len])ì— ë…¸ë“œ ì‚½ìž… í›„, ìœ„ ë°©í–¥ìœ¼ë¡œ percolating ìˆ˜í–‰

![Heap insertion](images/heap-insert.png)

- **ì‚­ì œ (pop; delete min)**
    - ê°€ìž¥ ë§ˆì§€ë§‰ì˜ ë…¸ë“œë¥¼ ì²« ë²ˆì§¸ë¡œ ì˜®ê¸´ í›„ ì•„ëž˜ ë°©í–¥ìœ¼ë¡œ percolating ìˆ˜í–‰

```c
void percolateDown(int[] A, int i, int N) {
    int child = 2 * i;
    int rightChild = 2 * i + 1;
    if (child >= N)
        return;
    if (rightChild < N && A[rightChild] < A[child]) // Min-heap
        child = rightChild;
    swap(A[i], A[child]);
    percolateDown(A, child, N);
}
```

- **ì‹œê°„ ë³µìž¡ë„ (Time Complexity)**
    - ê²€ìƒ‰ / ì‚½ìž… / ì‚­ì œ: `O(log n)`
    - Build heap: `O(n)`
    - Heap sort: `O(nlog n)`



### âœ”ï¸ ë‹¤ë¥¸ íŠ¸ë¦¬ë“¤

- **AVL**(Adelson-Velskii and Landis)
    - ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬ì™€ ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬ì˜ ë†’ì´ ì°¨ì´ê°€ 1ë³´ë‹¤ í¬ë©´ ì•ˆë¨
    - ì‚½ìž… ë° ì‚­ì œì‹œ ì¡°ê±´ì„ ê²€ì‚¬í•˜ê³  ë¶ˆë§Œì¡±ì‹œ íšŒì „ (rotate)
- **B-Tree**
    - ë…¸ë“  leaf ë…¸ë“œì˜ levelì´ ê°™ìŒ
    - í•œ ë…¸ë“œì˜ í‚¤ëŠ” ìµœëŒ€ b-1ê°œ
    - ëª¨ë“  non-leaf ë…¸ë“œëŠ” b-1ì´ìƒ bë¯¸ë§Œì˜ ìžì‹ ìˆ˜ë¥¼ ê°€ì§
- **RB(Red Black) Tree**
    - ë…¸ë“œì˜ ìƒ‰ê¹”ì„ redë‚˜ blackìœ¼ë¡œ ë‘ 
    - ì œì•½ì¡°ê±´ë“¤ì„ ë°”íƒ•ìœ¼ë¡œ íŠ¸ë¦¬ê°€ í•œìª½ìœ¼ë¡œ ì ë¦¬ì§€ ì•Šê²Œ í•´ì¤Œ



### âœ”ï¸ í•´ì‹± (Hashing)

- ê°™ì€ ê°’ì„ ë„£ìœ¼ë©´ í•­ìƒ ê°™ì€ ê°’ì´ ë‚˜ì˜¤ëŠ” í•¨ìˆ˜(Hash Function)ë¥¼ ì´ìš©í•˜ì—¬ í‚¤ë¥¼ ì°¾ì•„ë‚´ê³ , ì´ë¥¼ í…Œì´ë¸”ì˜ ì¸ë±ìŠ¤ë¡œ ì‚¬ìš©í•˜ì—¬ ì¡°íšŒ ë° ì‚½ìž…ì„ í•˜ëŠ” ë°©ì‹
- í•´ì‹œ í…Œì´ë¸” (Hash Table): ê³ ì •ëœ í¬ê¸°ë¥¼ ê°€ì§„ key-value í˜•ì‹ì˜ ìžë£Œêµ¬ì¡° (ì£¼ë¡œ ë°°ì—´ ì‚¬ìš©)
- í•´ì‹œ í…Œì´ë¸”ì˜ í¬ê¸°ê°€ ì¶©ë¶„í•˜ë©´ ê²€ìƒ‰, ì‚½ìž…, ì‚­ì œ ëª¨ë‘ `O(1)`ì˜ ì‹œê°„ ë³µìž¡ë„ë¥¼ ê°€ì§
- **í•´ì‹œ í•¨ìˆ˜ (Hash Function)**
    - ë‚˜ë¨¸ì§€ ì—°ì‚°(mod)ë¥¼ ì´ìš©í•˜ëŠ” ë°©ë²•
    - ASCCI ì½”ë“œë¥¼ ì´ìš©í•˜ëŠ” ë°©ë²•
    - ê¸°íƒ€ ë“±ë“±
- **ì¶©ëŒ (Collision)**
    - 2ê°œ ì´ìƒì˜ ë ˆì½”ë“œê°€ ê°™ì€ í‚¤ë¥¼ ê°€ì§ˆ ìˆ˜ ìžˆëŠ” ë¬¸ì œ
    - ë°©ë²• 1: Separate chaining
        - í•´ì‹œ í…Œì´ë¸”ì˜ ê° ë ˆì½”ë“œë¥¼ linked listë¡œ êµ¬ì„±í•˜ê³ , ê²€ìƒ‰ ì‹œ ìˆœíšŒí•˜ëŠ” ë°©ì‹
    - ë°©ë²• 2: Open addressing
        - ì´ë¯¸ ë ˆì½”ë“œê°€ ì‚¬ìš© ì¤‘ì´ë©´ ë‹¤ë¥¸ ë¹ˆ ê³µê°„ì„ ì‚¬ìš©í•˜ëŠ” ë°©ì‹
        - Linear probing: ìˆœì°¨ì ìœ¼ë¡œ ë‹¤ìŒ ë¹ˆ ë ˆì½”ë“œì— ì‚½ìž…
        - Quadratic probing: í‚¤ë¥¼ `i^2` ìˆœìœ¼ë¡œ ì¦ê°€ì‹œì¼œ ë¹ˆ ê³µê°„ ê²€ìƒ‰
    - ë°©ë²• 3: Extendible hashing
        - Directory êµ¬ì¡°ë¡œ í•´ì‹œ í…Œì´ë¸”ì„ êµ¬ì„±í•˜ëŠ” ë°©ì‹



## â³ ì•Œê³ ë¦¬ì¦˜

### âœ”ï¸ ì •ë ¬

- **ë²„ë¸” ì •ë ¬ (Bubble Sort)**
    - ì„œë¡œ ì¸ì ‘í•œ 2ê°œì˜ ë ˆì½”ë“œë¥¼ ë¹„êµí•˜ì—¬ í¬ê¸°ê°€ ìˆœì„œëŒ€ë¡œ ë˜ì–´ ìžˆì§€ ì•Šìœ¼ë©´ swap
    - 1íšŒì „ì‹œ d[1]ì™€ d[2], d[3]ì™€ d[4], ... d[n-1]ì™€ d[n]ë¥¼ ë¹„êµí•œë‹¤
    - kíšŒì „ì‹œ n-k+1ë²ˆ ê¹Œì§€ë§Œ ë¹„êµë¥¼ ìˆ˜í–‰í•˜ë©´ ëœë‹¤
    - `O(n^2)`
- **ì„ íƒ ì •ë ¬ (Selection Sort)**
    - í•´ë‹¹ ìˆœì„œì— ì›ì†Œë¥¼ ë„£ì„ ìœ„ì¹˜ëŠ” ì´ë¯¸ ì •í•´ì ¸ ìžˆê³ , ì–´ë–¤ ì›ì†Œë¥¼ ë„£ì„ì§€ ì„ íƒí•˜ëŠ” ì•Œê³ ë¦¬ì¦˜
    - kíšŒì „ì‹œ k ~ në²ˆì§¸ ë ˆì½”ë“œë“¤ì„ ë³´ì•„ì•¼ í•œë‹¤.
    - `O(n^2)`
- **ì‚½ìž… ì •ë ¬ (Insertion Sort)**
    - 2ë²ˆì§¸ ë ˆì½”ë“œë¶€í„° ì•žì˜ ë ˆì½”ë“œë“¤ì„ ë³´ë©° ìžì‹ ì´ ìœ„ì¹˜í•´ì•¼ í•  ê³³ìœ¼ë¡œ ì‚½ìž… í•˜ë©´ì„œ ì •ë ¬í•œë‹¤
    - kë²ˆì§¸ ë ˆì½”ë“œëŠ” 1~(k-1)ë²ˆì§¸ ë ˆì½”ë“œë“¤ê³¼ ë¹„êµí•´ì•¼í•œë‹¤
    - `O(n^2)`
- **í•©ë³‘ ì •ë ¬ (Merge Sort)**
    - ëŒ€í‘œì ì¸ ë¶„í•  ì •ë³µ(divide and conquer) ë°©ë²•
    - ì›ì†Œì˜ í¬ê¸°ê°€ 1ì´ ë  ë•Œê¹Œì§€ ë‘ê°œë¡œ ë¶„í• í•œ í›„, 2ê°œì˜ ë¦¬ìŠ¤íŠ¸ì˜ ê°’ë“¤ì„ ì²˜ìŒë¶€í„° í•˜ë‚˜ì”© ë¹„êµí•˜ì—¬ ë‘ ê°œì˜ ë¦¬ìŠ¤íŠ¸ì˜ ê°’ ì¤‘ì—ì„œ ë” ìž‘ì€ ê°’ì„ ìƒˆë¡œìš´ ë¦¬ìŠ¤íŠ¸(sorted)ë¡œ ì˜®ê¸´ë‹¤.
    - `O(n^2)`
    - âŒ In-place algorithm(ì œìžë¦¬ ì•Œê³ ë¦¬ì¦˜)ì´ ì•„ë‹ˆë‹¤; `O(n)`ë§Œí¼ì˜ ìƒˆë¡œìš´ ê³µê°„ ìš”êµ¬
- **íž™ ì •ë ¬ (Heap Sort)**
    - ë°°ì—´ì˜ ìš”ì†Œë¡œ max heapì„ build í•˜ê³ , í•˜ë‚˜ì”© ìš”ì†Œë¥¼ êº¼ë‚´ì„œ ë°°ì—´ì˜ ë’¤ë¶€í„° ì €ìž¥í•˜ë©´ ëœë‹¤. (ë³„ë„ ê³µê°„ ë¶ˆí•„ìš”)
    - `O(nlog n)`
    - âœ… In-place algorithmìž„
- **í€µ ì •ë ¬ (Quick Sort)**
    - ê°œë…
        - ë¦¬ìŠ¤íŠ¸ ì•ˆì˜ í•œ ìš”ì†Œë¥¼ ê³ ë¥´ê³ , ì´ë¥¼ í”¼ë²—(pivot)ì´ë¼ í•œë‹¤. í”¼ë²—ì„ ê¸°ì¤€ìœ¼ë¡œ ìž‘ì€ ìš”ì†Œë“¤ì€ í”¼ë²— ì™¼ìª½ìœ¼ë¡œ ë³´ë‚´ê³ , í° ìš”ì†Œë“¤ì€ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ë³´ë‚¸ë‹¤
        - í”¼ë²—ì„ ì œì™¸í•œ ì™¼ìª½ ë¦¬ìŠ¤íŠ¸ì™€ ì˜¤ë¥¸ìª½ ë¦¬ìŠ¤íŠ¸ ê°ê°ì— ëŒ€í•´ ìœ„ ìž‘ì—…ì„ ë°˜ë³µí•œë‹¤.
    - êµ¬í˜„ ë°©ë²•
        - `low` í¬ì¸í„°ì™€ `high` í¬ì¸í„°ë¥¼ ë‘ê³ , lowëŠ” ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™í•˜ë‹¤ê°€ í”¼ë²—ë³´ë‹¤ í° ìš”ì†Œë¥¼ ì°¾ìœ¼ë©´ ë©ˆì¶˜ë‹¤. highëŠ” ì™¼ìª½ìœ¼ë¡œ ì´ë™í•˜ë‹¤ê°€ í”¼ë²—ë³´ë‹¤ ìž‘ì€ ìš”ì†Œë¥¼ ì°¾ìœ¼ë©´ ë©ˆì¶˜ë‹¤. ë‘ í¬ì¸í„° ëª¨ë‘ ë©ˆì¶”ë©´ êµí™˜í•˜ê³ , ë‘ í¬ì¸í„°ê°€ ì—‡ê°ˆë¦´ ë•Œê¹Œì§€ ë°˜ë³µí•œë‹¤.
    - í‰ê·  ì‹œê°„ë³µìž¡ë„: `O(nlog n)`, ìµœì•… ì‹œê°„ë³µìž¡ë„: `O(n^2)`
    - âš ï¸ ìµœì•…ì˜ ê²½ìš°(Worst Case)
        - ë¦¬ìŠ¤íŠ¸ê°€ ìž˜ ë‚˜ëˆ ì§€ì§€ ì•ŠëŠ” ê²½ìš° (í”¼ë²—ì´ ìµœëŒ€ê°’, í˜¹ì€ ìµœì†Ÿê°’ìœ¼ë¡œ ë½‘í˜€ì„œ ë¦¬ìŠ¤íŠ¸ê°€ ë‚˜ëˆ„ì–´ì§€ì§€ ì•Šê³  ê¸¸ì´ë§Œ 1ì”© ì¤„ì–´ë“œëŠ” ê²½ìš°)
    - â‰ï¸ In-place algorithmì´ë¼ê³  í•  ìˆ˜ë„ ìžˆê³ , ê·¸ë ‡ì§€ ì•Šë‹¤ê³  í•  ìˆ˜ë„ ìžˆë‹¤
        - O(log n) ë§Œí¼ì˜ spaceë¥¼ í•„ìš”ë¡œ í•˜ë©°, ìµœì•…ì˜ ê²½ìš°ì— O(n)ê¹Œì§€ë„ í•„ìš”í•˜ë‹¤.



### âœ”ï¸ BFSì™€ DFS

- **BFS(ë„ˆë¹„ ìš°ì„  íƒìƒ‰; Breadth-first search)**
    - í(queue)ë¥¼ ì´ìš©í•˜ì—¬ íƒìƒ‰ì„ ìˆ˜í–‰í•œë‹¤
- **DFS(ê¹Šì´ ìš°ì„  íƒìƒ‰; Depth-first search)**
    - ìŠ¤íƒ(stack)ì´ë‚˜ ìž¬ê·€ í•¨ìˆ˜(í˜¹ì€ ìˆœí™˜ í˜¸ì¶œ)ë¥¼ ì´ìš©í•˜ì—¬ íƒìƒ‰ì„ ìˆ˜í–‰í•œë‹¤



### âœ”ï¸ ë‹¤ìµìŠ¤íŠ¸ë¼ (Dijkstra)

- ì¶œë°œì (source)ì´ ëª…ì‹œë˜ì–´ìžˆê³ , ê° ë…¸ë“œê¹Œì§€ì˜ ìµœë‹¨ ê²½ë¡œë¥¼ êµ¬í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜
- ê°œë…
    - BFSë¥¼ ê¸°ë³¸ìœ¼ë¡œ í•œë‹¤
    - íì— ìžˆëŠ” vertexë“¤ì„ í•˜ë‚˜ì”© êº¼ë‚´ë©° ì´ì›ƒë“¤ì˜ ìµœë‹¨ê²½ë¡œë¥¼ ê°±ì‹ í•´ì¤€ë‹¤
        - `dist[v] = min(dist[v], dist[u] + edge[u][v])`
    - â—ï¸íì—ì„œ vertexë¥¼ êº¼ë‚¼ ë•Œì—ëŠ” ê°€ìž¥ ì§§ì€ ìµœë‹¨ ê²½ë¡œë¥¼ ê°€ì§„ ë†ˆì„ ë¨¼ì € êº¼ë‚´ë„ë¡ í•œë‹¤
- ê¸°ë³¸ ì‹œê°„ë³µìž¡ë„: `O(V^2 + E)`

```js
dist[source] â† 0
create vertex set Q

for each vertex v in Graph:
  dist[v] â† INFINITY  // ì†ŒìŠ¤ì—ì„œ vê¹Œì§€ì˜ ì•„ì§ ëª¨ë¥´ëŠ” ê¸¸ì´
	prev[v] â† UNDEFINED  // ì†ŒìŠ¤ì—ì„œ ìµœì  ê²½ë¡œì˜ ì´ì „ ê¼­ì§“ì 
	add v to Q  // ëª¨ë“  ë…¸ë“œëŠ” ì´ˆê¸°ì— Qì— ì†í•´ìžˆë‹¤ (ë¯¸ë°©ë¬¸ ì§‘í•©)

dist[source] â† 0  // ì†ŒìŠ¤ì—ì„œ ì†ŒìŠ¤ê¹Œì§€ì˜ ê¸¸ì´

while Q is not empty:
	u â† vertex in Q with min dist[u] // ìµœì†Œ ê±°ë¦¬ë¥¼ ê°–ëŠ” ê¼­ì§“ì ì„ ê°€ìž¥ ë¨¼ì € ì„ íƒí•œë‹¤
	remove u from Q

	for each neighbor v of u:           // vëŠ” ì—¬ì „ížˆ Qì— ìžˆë‹¤.
		alt â† dist[u] + length(u, v)
		if alt < dist[v]:               // v ê¹Œì§€ì˜ ë” ì§§ì€ ê²½ë¡œë¥¼ ì°¾ì•˜ì„ ë•Œ
			dist[v] â† alt
			prev[v] â† u

return dist[], prev[]
```





---

### ì°¸ê³  ìžë£Œ

- í•œì–‘ëŒ€í•™êµ ìžë£Œêµ¬ì¡°ë¡  ìˆ˜ì—… ê°•ì˜ìžë£Œ, ë…¸ë¯¸ë‚˜ êµìˆ˜ (CSE2010)
  - êµìž¬ - Fundamentals of Data Structures in C 2/e, Horowitz ì™¸
- í•œì–‘ëŒ€í•™êµ ì•Œê³ ë¦¬ì¦˜ ìˆ˜ì—… ê°•ì˜ìžë£Œ, ë°•í¬ì§„ êµìˆ˜ (ITE2039)
  - êµìž¬ - Introduction to Algorithms 3/e, T Cormen, C ì™¸
- https://gmlwjd9405.github.io
